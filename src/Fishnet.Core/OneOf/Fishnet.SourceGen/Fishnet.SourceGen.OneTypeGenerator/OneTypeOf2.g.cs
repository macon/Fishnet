// <auto-generated />
namespace Fishnet.Core;

public readonly record struct One<T1, T2>
{
    public Opt<T1> Opt1 {get;}
    public Opt<T2> Opt2 {get;}

    internal Variant Index { get; }
    internal enum Variant { T1, T2 }

    internal T1 ValT1 => Opt1.GetOrDie();
    internal T2 ValT2 => Opt2.GetOrDie();

    public ISome Some => Index switch
    {
        Variant.T1 => new Some<T1>(ValT1),
        Variant.T2 => new Some<T2>(ValT2),
        _ => throw new FunctionalStateException($"{nameof(Index)} out of range")
    };

    public void Deconstruct(out Opt<T1> t1, out Opt<T2> t2) => (t1, t2) = (Opt1, Opt2);

    public bool IsT1 => Index == Variant.T1;
    public bool IsT2 => Index == Variant.T2;

    public One(T1 value) => (Opt1, Index) = (value, Variant.T1);
    public One(T2 value) => (Opt2, Index) = (value, Variant.T2);

    public static implicit operator One<T1, T2>(T1 value) => new(value);
    public static implicit operator One<T1, T2>(T2 value) => new(value);
}

public static partial class OneExt
{
    public static R Match<T1, T2, R>(
        this One<T1, T2> one,
        Func<T1, R> t1Func,
        Func<T2, R> t2Func
    ) =>
        one switch
        {
            { Index: One<T1, T2>.Variant.T1 } => t1Func(one.ValT1),
            { Index: One<T1, T2>.Variant.T2 } => t2Func(one.ValT2),
            _ => throw new FunctionalStateException($"{nameof(Index)} out of range")
        };

    /// <summary>
    /// Projects a One&lt;T1, ...&gt; to a One&lt;R1, ...&gt; using the provided mapping functions.
    /// </summary>
    public static One<R1, R2> Map<T1, T2, R1, R2>(
        this One<T1, T2> one,
        Func<T1, R1> t1Func,
        Func<T2, R2> t2Func
    ) =>
        one.Match(
            t1 => new One<R1, R2>(t1Func(t1)),
            t2 => new One<R1, R2>(t2Func(t2))
        );

    /// <summary>
    /// Possibly projects a One&lt;T1, ...&gt; to an Opt&lt;One&lt;R1, ...&gt;&gt; using the optionally provided mapping functions.
    /// </summary>
    public static Opt<One<R1, R2>> Map<T1, T2, R1, R2>(
        this One<T1, T2> one,
        Opt<Func<T1, R1>> t1Func,
        Opt<Func<T2, R2>> t2Func
    ) =>
        one.Match<T1, T2, Opt<One<R1, R2>>>(
            t1 => t1Func
                .Map(f => f(t1))
                .Match(
                    none: () => Opt<One<R1, R2>>.None,
                    some: s => Some(new One<R1, R2>(s))),
            t2 => t2Func
                .Map(f => f(t2))
                .Match(
                    none: () => Opt<One<R1, R2>>.None,
                    some: s => Some(new One<R1, R2>(s)))
        );

    
    /// <summary>
    /// Possibly projects a <c>One&lt;T1, T2&gt;</c> to an <c>Opt&lt;One&lt;R1, T2&gt;&gt;</c> using the T1->R1 mapping function.
    /// </summary>
    /// <returns><c>None</c> if <c>one != T1</c></returns>
    public static Opt<One<R1, T2>> Map<T1, T2, R1>(
        this One<T1, T2> one,
        Func<T1, R1> t1Func
    ) =>
        one.IsT1
            ? Some(new One<R1, T2>(t1Func(one.ValT1)))
            : Opt<One<R1, T2>>.None;
    
    /// <summary>
    /// Possibly projects a <c>One&lt;T1, T2&gt;</c> to an <c>Opt&lt;One&lt;R1, T2&gt;&gt;</c> using the T1->R1 mapping function.
    /// </summary>
    /// <returns><c>None</c> if <c>one != T1</c></returns>
    public static Opt<One<T1, R2>> Map<T1, T2, R2>(
        this One<T1, T2> one,
        Func<T2, R2> t2Func
    ) =>
        one.IsT2
            ? Some(new One<T1, R2>(t2Func(one.ValT2)))
            : Opt<One<T1, R2>>.None;
}
