// <auto-generated />
namespace Fishnet.Core;

public readonly record struct One<|repeat_csv|T@n|>
{
    |repeat_line|public Opt<T@n> Opt@n {get;}

    internal Variant Index { get; }
    internal enum Variant { |repeat_csv|T@n| }

    |repeat_line|internal T@n ValT@n => Opt@n.GetOrDie();

    public ISome Some => Index switch
    {
        |repeat_line|Variant.T@n => new Some<T@n>(ValT@n),
        _ => throw new FunctionalStateException($"{nameof(Index)} out of range")
    };

    public void Deconstruct(|repeat_csv|out Opt<T@n> t@n|) => (|repeat_csv|t@n|) = (|repeat_csv|Opt@n|);

    |repeat_line|public bool IsT@n => Index == Variant.T@n;

    |repeat_line|public One(T@n value) => (Opt@n, Index) = (value, Variant.T@n);

    |repeat_line|public static implicit operator One<|repeat_csv|T@n|>(T@n value) => new(value);
}

public static partial class OneExt
{
    public static R Match<|repeat_csv|T@n|, R>(
        this One<|repeat_csv|T@n|> one,
        |repeat_line_csv|Func<T@n, R> t@nFunc
    ) =>
        one switch
        {
            |repeat_line|{ Index: One<|repeat_csv|T@n|>.Variant.T@n } => t@nFunc(one.ValT@n),
            _ => throw new FunctionalStateException($"{nameof(Index)} out of range")
        };

    /// <summary>
    /// Projects a One&lt;T1, ...&gt; to a One&lt;R1, ...&gt; using the provided mapping functions.
    /// </summary>
    public static One<|repeat_csv|R@n|> Map<|repeat_csv|T@n|, |repeat_csv|R@n|>(
        this One<|repeat_csv|T@n|> one,
        |repeat_line_csv|Func<T@n, R@n> t@nFunc
    ) =>
        one.Match(
            |repeat_line_csv|t@n => new One<|repeat_csv|R@n|>(t@nFunc(t@n))
        );

    /// <summary>
    /// Possibly projects a One&lt;T1, ...&gt; to an Opt&lt;One&lt;R1, ...&gt;&gt; using the optionally provided mapping functions.
    /// </summary>
    public static Opt<One<|repeat_csv|R@n|>> Map<|repeat_csv|T@n|, |repeat_csv|R@n|>(
        this One<|repeat_csv|T@n|> one,
        |repeat_line_csv|Opt<Func<T@n, R@n>> t@nFunc
    ) =>
        one.Match<|repeat_csv|T@n|, Opt<One<|repeat_csv|R@n|>>>(
            |repeat_multi_line_csv|t@n => t@nFunc
                .Map(f => f(t@n))
                .Match(
                    none: () => Opt<One<|repeat_csv|R@n|>>.None,
                    some: s => Some(new One<|repeat_csv|R@n|>(s)))|
        );

    |repeat_multi_line_semicolon|
    /// <summary>
    /// Possibly projects a <c>One&lt;T1, T2&gt;</c> to an <c>Opt&lt;One&lt;R1, T2&gt;&gt;</c> using the T1->R1 mapping function.
    /// </summary>
    /// <returns><c>None</c> if <c>one != T1</c></returns>
    public static Opt<One<|repeat_with_intersect_csv|T@n|R@n|>> Map<|repeat_csv|T@n|, R@n>(
        this One<|repeat_csv|T@n|> one,
        Func<T@n, R@n> t@nFunc
    ) =>
        one.IsT@n
            ? Some(new One<|repeat_with_intersect_csv|T@n|R@n|>(t@nFunc(one.ValT@n)))
            : Opt<One<|repeat_with_intersect_csv|T@n|R@n|>>.None|
}
